# אלגוריתם דייקסטרה (Dijkstra's Algorithm)

_קרא בשפות אחרות:_
[_English_](README.md),
[_한국어_](README.ko-KR.md),
[_日本語_](README.ja-JP.md),
[_简体中文_](README.zh-CN.md),
[_繁體中文_](README.zh-TW.md),
[_Українська_](README.uk-UA.md),
[_Español_](README.es-ES.md),
[_Français_](README.fr-FR.md),
[_Deutsch_](README.de-DE.md),
[_עברית_](README.he-IL.md)

אלגוריתם דייקסטרה הוא אלגוריתם למציאת המסלולים הקצרים ביותר בין צמתים בגרף, שיכול לייצג למשל רשת כבישים.

לאלגוריתם יש מספר גרסאות; הגרסה המקורית של דייקסטרה מצאה את המסלול הקצר ביותר בין שני צמתים, אך גרסה נפוצה יותר קובעת צומת אחד כ"צומת מקור" ומוצאת את המסלולים הקצרים ביותר ממנו לכל שאר הצמתים בגרף, וכך נוצרת עץ מסלולים קצרים (Shortest-Path Tree).

![Dijkstra](https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif)

אלגוריתם דייקסטרה למציאת המסלול הקצר ביותר בין `a` ל־`b`.
הוא בוחר את הצומת שלא ביקרו בו שעד כה יש לו את המרחק הקטן ביותר,
מחשב את המרחק דרכו לכל שכן שלא ביקרו בו,
ומעדכן את המרחק אם נמצא מסלול קצר יותר.
כאשר מסיימים לבדוק את כל השכנים, מסמנים את הצומת כ"ביקור הושלם" (אדום).

## שימושים מעשיים של אלגוריתם דייקסטרה

- מערכות GPS / ניווט
- אופטימיזציה של מסלולי תחבורה ציבורית וטיסות
- ניתוב באינטרנט (פרוטוקולים OSPF, IS-IS)
- אופטימיזציה של תעבורת רשת וזמני השהיה
- חיפוש מסלולים במשחקים (המסלול הקצר ביותר במפה)
- אופטימיזציה של מסלולי משלוחים ולוגיסטיקה
- תכנון רשתות תחבורה ושרשראות אספקה

## דוגמה שלב-אחר-שלב לאלגוריתם דייקסטרה

נניח שיש לנו גרף משוקלל של צמתים, שבו לכל קשת יש ערך מרחק בין צמתים.
לדוגמה, המרחק בין הצומת `A` לצומת `B` הוא `7 מטרים` (או בקיצור `7m`).

האלגוריתם משתמש ב[תור עדיפויות](../../../data-structures/priority-queue/) כדי תמיד לבחור את הצומת שלא ביקרו בו עם המרחק הקטן ביותר מהצומת ההתחלתי.

צומת ההתחלה, על פי ההגדרה, נמצא במרחק `0m` מעצמו.
לכן מתחילים ממנו — הצומת היחיד בתור העדיפויות בתחילת התהליך.

שאר הצמתים יתווספו לתור במהלך המעבר בגרף (בעת ביקור בשכנים).

![Dijkstra step 1](./images/dijkstra-01.png)

כל שכן של הצומת שנשלף מהתור נבדק כדי לחשב את המרחק אליו מהמקור.
לדוגמה, המרחק מ־`A` ל־`B` הוא `0m + 7m = 7m`.

בכל פעם שמבקרים שכן חדש שטרם נבדק, מוסיפים אותו לתור העדיפויות,
כאשר העדיפות נקבעת לפי המרחק מהמקור.

הצומת `B` נוסף לתור העדיפויות המינימלי כדי לעבור עליו מאוחר יותר.

![Dijkstra step 2](./images/dijkstra-02.png)

מבקרים את השכן הבא של `A`, שהוא `C`.
המרחק מ־`A` ל־`C` הוא `0m + 9m = 9m`.

הצומת `C` נוסף גם הוא לתור העדיפויות.

![Dijkstra step 3](./images/dijkstra-03.png)

כנ"ל לגבי הצומת `F`.
המרחק הנוכחי מ־`A` ל־`F` הוא `0m + 14m = 14m`.

`F` נוסף לתור כדי לעבור עליו בהמשך.

![Dijkstra step 4](./images/dijkstra-04.png)

לאחר שכל השכנים של הצומת הנוכחי נבדקו, מוסיפים אותו לקבוצת `visited`.
אין צורך לבקר בו שוב.

כעת נשלוף מהתור את הצומת הקרוב ביותר למקור (בעל המרחק הקצר ביותר)
ונתחיל לבקר את שכניו.

![Dijkstra step 5](./images/dijkstra-05.png)

אם הצומת שבו אנו מבקרים (למשל `C`) כבר נמצא בתור,
המשמעות היא שכבר חישבנו את המרחק אליו, אבל ממסלול אחר (`A → C`).
אם המרחק הנוכחי (דרך המסלול `A → B → C`) קצר יותר, נעדכן אותו;
אם ארוך יותר — נשאיר אותו כפי שהוא.

לדוגמה, בעת ביקור ב־`C` דרך `B` (`A → B → C`), המרחק הוא `7m + 10m = 17m`.
זה ארוך יותר מהמרחק שכבר נרשם (`9m`), ולכן אין עדכון.

![Dijkstra step 6](./images/dijkstra-06.png)

מבקרים שכן נוסף של `B`, שהוא `D`.
המרחק ל־`D` הוא `7m + 15m = 22m`.
מכיוון שטרם ביקרנו ב־`D` והוא אינו בתור, נוסיף אותו עם עדיפות (מרחק) של `22m`.

![Dijkstra step 7](./images/dijkstra-07.png)

בשלב זה כל שכניו של `B` נבדקו, ולכן נוסיף את `B` לקבוצת `visited`.
לאחר מכן נשלוף את הצומת הקרוב ביותר למקור מהתור.

![Dijkstra step 8](./images/dijkstra-08.png)

מבקרים את השכנים הלא-מבוקרים של `C`.
המרחק ל־`F` דרך `C` (המסלול `A → C → F`) הוא `9m + 2m = 11m`.
זה קצר יותר מהמרחק שנרשם קודם (`14m` ל־`A → F`).
לכן נעדכן את המרחק של `F` ל־`11m` ואת העדיפות שלו בתור.
מצאנו מסלול קצר יותר ל־`F`.

![Dijkstra step 9](./images/dijkstra-09.png)

אותו הדבר עבור `D`.
מצאנו מסלול קצר יותר — `A → C → D` קצר מ־`A → B → D`.
נעדכן את המרחק מ־`22m` ל־`20m`.

![Dijkstra step 10](./images/dijkstra-10.png)

כל שכניו של `C` נבדקו, ולכן נוסיף את `C` ל־`visited`.
נשלוף מהתור את הצומת הקרוב ביותר הבא — `F`.

![Dijkstra step 11](./images/dijkstra-11.png)

נרשום את המרחק ל־`E` כ־`11m + 9m = 20m`.

![Dijkstra step 12](./images/dijkstra-12.png)

נוסיף את `F` לקבוצת `visited`, ונשלוף את הצומת הקרוב הבא — `D`.

![Dijkstra step 13](./images/dijkstra-13.png)

המרחק ל־`E` דרך `D` הוא `20m + 6m = 26m`.
זה ארוך יותר מהמרחק שכבר חושב (`20m` דרך `F`), ולכן נתעלם ממנו.

![Dijkstra step 14](./images/dijkstra-14.png)

הצומת `D` כעת סומן כ"ביקור הושלם".

![Dijkstra step 15](./images/dijkstra-15.png)

הצומת `E` גם סומן כ"ביקור הושלם".
סיימנו את המעבר בגרף.

![Dijkstra step 16](./images/dijkstra-16.png)

כעת אנו יודעים את המרחקים הקצרים ביותר מכל צומת לנקודת ההתחלה `A`.

בפועל, במהלך חישוב המרחקים שומרים גם את ה־`previousVertices` (הצמתים הקודמים)
כדי שנוכל לשחזר את הרצף המדויק של הצמתים שמרכיבים את המסלול הקצר ביותר.

לדוגמה, המסלול הקצר מ־`A` ל־`E` הוא `A → C → F → E`.

## דוגמת מימוש

- [dijkstra.js](./dijkstra.js)

## מקורות

- [ויקיפדיה](https://he.wikipedia.org/wiki/אלגוריתם_דייקסטרה)
- [YouTube – Nathaniel Fan](https://www.youtube.com/watch?v=gdmfOwyQlcI&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)
- [YouTube – Tushar Roy](https://www.youtube.com/watch?v=lAXZGERcDf4&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)
